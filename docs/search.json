{
  "articles": [
    {
      "path": "1-O_que_e_R.html",
      "title": "O que é R?",
      "description": "Tipos de Varíaveis e Estrutura de Dados",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 5, 2021",
      "contents": "\n\nContents\nConteúdos\nProfessor\nO que é R?\nTipos de Variáveis do R\nEstruturas de Dados\nO que podemos fazer com vetores e listas?\ndata.frames e tibbles\n\nVetores Especiais – factor\nValores Especiais\npacote::funcao()\nAmbiente\n\n\nBem vindos à disciplina!\n\n\n\nFigure 1: Bem-vindo!\n\n\n\nConteúdos\nVamos usar todo o universo do {tidyverse}!\nAula 1 - O que é R?\nAula 2 e 3 — dplyr e manipulação de dados\nAula 4 e 5 — ggplot2 e visualização de dados\nAula 6 — Programação funcional com purrr e furrr\nAula 7 — Regressão Linear e Regressão Logística\nProfessor\nJosé Eduardo Storopoli (Duda)\nO que é R?\nR vem da linguagem S que é uma linguagem estatística desenvolvida na Bell Labs na década de 1970s. E R é o “filho” opensource do S.\nRmarkdown é uma boa combinação de gráficos, narrativa e código. Veja o exemplo da figura abaixo.\n\n\n\nFigure 2: Exemplo de um Plot em R\n\n\n\nTipos de Variáveis do R\nnumeric\ninteger\ndouble\n\nlogical\ncharacter\n\n\ntypeof(1L)\n\n\n[1] \"integer\"\n\ntypeof(1.0)\n\n\n[1] \"double\"\n\ntypeof(TRUE)\n\n\n[1] \"logical\"\n\ntypeof(\"Oi!\")\n\n\n[1] \"character\"\n\nis.numeric(1)\n\n\n[1] TRUE\n\nEstruturas de Dados\nMesmo tipo de variáveis:\n1-D: Vetores c(...)\n2-D: Matrizes matrix()\nN-D: Arrays array()\n\nTipos diferentes de variáveis:\n1-D: Listas list(...)\n2-D: Dataframes data.frame(...) ou tibble(...)\n\n\nOBS: Para designar podemos usar o x = valor, mas usamos o <- pois não permite equivalência ela assinala tudo que está a direita da flecha para a variável à esquerda da flecha. Ex x <- valor (similar ao x := valor). Inclusive alt + - gera um <- com um whitespace ao redor.\n\n\n\nvetor_integer <- c(1L, 7L:9L)\nvetor_integer\n\n\n[1] 1 7 8 9\n\ntypeof(vetor_integer)\n\n\n[1] \"integer\"\n\nis.numeric(vetor_integer)\n\n\n[1] TRUE\n\nvetor_doubles <- c(1, 7:9)\nvetor_doubles\n\n\n[1] 1 7 8 9\n\ntypeof(vetor_doubles)\n\n\n[1] \"double\"\n\nis.numeric(vetor_doubles)\n\n\n[1] TRUE\n\nvetor_logical <- c(TRUE, FALSE)\nvetor_logical\n\n\n[1]  TRUE FALSE\n\ntypeof(vetor_logical)\n\n\n[1] \"logical\"\n\nvetor_character <- c(\"Oi!\", \"Tchau!\")\nvetor_character\n\n\n[1] \"Oi!\"    \"Tchau!\"\n\ntypeof(vetor_character)\n\n\n[1] \"character\"\n\n\n\nlista_mista <- list(\"Oi!\", TRUE, 1L)\ntypeof(lista_mista)\n\n\n[1] \"list\"\n\nvetor_coerce <- c(\"Oi!\", TRUE, 1L)\nvetor_coerce\n\n\n[1] \"Oi!\"  \"TRUE\" \"1\"   \n\ntypeof(vetor_coerce)\n\n\n[1] \"character\"\n\n\nOBS: Named List\n\n\n\nlista_nomeada <- list(\n  \"character\" = \"Oi!\",\n  \"logical\" = TRUE,\n  \"integer\" = 1L\n)\n\nstr(lista_nomeada)\n\n\nList of 3\n $ character: chr \"Oi!\"\n $ logical  : logi TRUE\n $ integer  : int 1\n\nO que podemos fazer com vetores e listas?\ndimensões - dim()\ncomprimento - length()\nIndexar:\nlista[1] - retornará sempre uma list\nlista[[1]] - retornará sempre um elemento\nlista$1 atalho para lista[[\"1\"]]\nlista$nome - atalho para lista[[\"nome\"]]\nlista[\"nome\"] - retonará sempre uma list\nlista[[\"nome\"]] - retornará sempre uma list\n\nFatiar:\nlista[1:30]\n\n\n\nstr(lista_nomeada[1])\n\n\nList of 1\n $ character: chr \"Oi!\"\n\nstr(lista_nomeada[[1]])\n\n\n chr \"Oi!\"\n\nstr(lista_nomeada$logical)\n\n\n logi TRUE\n\nstr(lista_nomeada[[\"logical\"]])\n\n\n logi TRUE\n\nstr(lista_nomeada[\"character\"])\n\n\nList of 1\n $ character: chr \"Oi!\"\n\nstr(lista_nomeada[1:2])\n\n\nList of 2\n $ character: chr \"Oi!\"\n $ logical  : logi TRUE\n\ndata.frames e tibbles\n\n\ndf <- data.frame(\n  a = sample(c(\"A\", \"B\"), 100, replace = TRUE),\n  x = runif(100),\n  y = rnorm(100),\n  dia = \"hoje\"\n)\ndf\n\n\n    a     x      y  dia\n1   B 0.135  0.253 hoje\n2   B 0.371 -0.721 hoje\n3   A 0.645  1.874 hoje\n4   A 0.669 -1.208 hoje\n5   A 0.428  1.126 hoje\n6   B 0.392 -0.186 hoje\n7   B 0.096 -1.302 hoje\n8   B 0.812  0.038 hoje\n9   A 0.831  0.767 hoje\n10  A 0.339 -1.684 hoje\n11  B 0.919 -1.093 hoje\n12  A 0.441 -0.058 hoje\n13  B 0.012  0.974 hoje\n14  B 0.027  2.844 hoje\n15  B 0.244  0.777 hoje\n16  A 0.860  0.037 hoje\n17  A 0.600  0.768 hoje\n18  A 0.779 -1.209 hoje\n19  A 0.512 -1.371 hoje\n20  A 0.272 -0.192 hoje\n21  B 0.877  0.153 hoje\n22  A 0.240  0.947 hoje\n23  A 0.255 -0.804 hoje\n24  B 0.767  0.254 hoje\n25  A 0.494 -0.751 hoje\n26  A 0.959  0.966 hoje\n27  B 0.891 -1.680 hoje\n28  A 0.835 -0.051 hoje\n29  A 0.903  0.853 hoje\n30  A 0.267 -0.136 hoje\n31  A 0.625  1.789 hoje\n32  A 0.613  0.366 hoje\n33  B 0.426 -0.010 hoje\n34  B 0.975 -1.297 hoje\n35  A 0.080 -1.636 hoje\n36  A 0.580  0.562 hoje\n37  A 0.901  0.064 hoje\n38  A 0.918 -1.258 hoje\n39  A 0.435 -0.618 hoje\n40  B 0.148  0.497 hoje\n41  A 0.952 -0.866 hoje\n42  B 0.677 -0.929 hoje\n43  A 0.762 -0.600 hoje\n44  B 0.123  0.403 hoje\n45  B 0.213  0.704 hoje\n46  B 0.586  0.416 hoje\n47  B 0.525  0.675 hoje\n48  A 0.617  1.460 hoje\n49  B 0.798 -0.780 hoje\n50  A 0.021  0.647 hoje\n51  A 0.228  1.178 hoje\n52  B 0.338 -0.445 hoje\n53  B 0.204  0.278 hoje\n54  A 0.655 -0.542 hoje\n55  A 0.310 -0.992 hoje\n56  B 0.473  0.206 hoje\n57  A 0.166 -1.841 hoje\n58  B 0.585  0.432 hoje\n59  B 0.170  0.333 hoje\n60  A 0.047 -0.758 hoje\n61  B 0.682 -0.388 hoje\n62  B 0.617 -1.464 hoje\n63  B 0.379  0.057 hoje\n64  A 0.649 -1.467 hoje\n65  A 0.355 -0.956 hoje\n66  B 0.350  0.128 hoje\n67  A 0.334 -0.015 hoje\n68  A 0.128 -0.523 hoje\n69  A 0.816 -0.841 hoje\n70  B 0.903  0.866 hoje\n71  B 0.752 -1.099 hoje\n72  B 0.585  0.334 hoje\n73  B 0.768 -0.151 hoje\n74  B 0.345 -0.680 hoje\n75  B 0.031 -1.159 hoje\n76  A 0.777  0.212 hoje\n77  A 0.212 -0.847 hoje\n78  A 0.620 -0.364 hoje\n79  A 0.786  0.990 hoje\n80  B 0.085  0.054 hoje\n81  B 0.681  0.464 hoje\n82  B 0.822  0.205 hoje\n83  B 0.735  0.931 hoje\n84  A 0.584  1.433 hoje\n85  B 0.945  1.953 hoje\n86  B 0.761 -1.195 hoje\n87  B 0.477 -0.099 hoje\n88  A 0.032  0.694 hoje\n89  B 0.841 -0.338 hoje\n90  B 0.818 -0.719 hoje\n91  A 0.893 -0.732 hoje\n92  B 0.498 -0.599 hoje\n93  A 0.953 -1.588 hoje\n94  B 0.849 -1.567 hoje\n95  A 0.282 -0.882 hoje\n96  B 0.724 -0.525 hoje\n97  A 0.147 -0.050 hoje\n98  A 0.795 -1.241 hoje\n99  B 0.065 -0.928 hoje\n100 A 0.384  1.181 hoje\n\nPara solucionar a facilidade de visualização e inspeção de data.frames o {tidyverse} possui uma estrutura de dados chamada tibble:\n\n\nlibrary(tibble)\nconvert_df <- as_tibble(df)\nstr(convert_df)\n\n\ntibble[,4] [100 × 4] (S3: tbl_df/tbl/data.frame)\n $ a  : chr [1:100] \"B\" \"B\" \"A\" \"A\" ...\n $ x  : num [1:100] 0.135 0.371 0.645 0.669 0.428 ...\n $ y  : num [1:100] 0.253 -0.721 1.874 -1.208 1.126 ...\n $ dia: chr [1:100] \"hoje\" \"hoje\" \"hoje\" \"hoje\" ...\n\nOutra vantagem do tibble é que eu consigo criar colunas com base em colunas “passadas”. Por exemplo isso dá um erro com a função data.frame:\n\n\ndf_error <- data.frame(\n  a = 1:10,\n  b = a + 1\n)\n\n\n\nJá no tibble eu consigo!\n\n\ntbl <- tibble(\n  a = 1:10,\n  b = a + 1\n)\ntbl_complexa <- tibble(\n  idade_ano = rnorm(100, mean = 30, sd = 10),\n  altura_cm = rnorm(100, mean = 165, sd = 10),\n  peso_kg = rnorm(100, mean = 70, sd = 10),\n  IMC = peso_kg / (altura_cm ^ 2),\n  glicose = rexp(100, rate = IMC / 10)\n)\ntbl_complexa\n\n\n# A tibble: 100 x 5\n   idade_ano altura_cm peso_kg     IMC glicose\n       <dbl>     <dbl>   <dbl>   <dbl>   <dbl>\n 1      20.7      152.    66.9 0.00288   1696.\n 2      34.9      157.    73.5 0.00299   2011.\n 3      17.4      162.    61.6 0.00234   7197.\n 4      37.4      164.    71.9 0.00267   2160.\n 5      31.1      171.    83.0 0.00283   1652.\n 6      26.0      158.    85.1 0.00340   3828.\n 7      17.9      150.    77.3 0.00343   2045.\n 8      40.1      181.    89.6 0.00275   3144.\n 9      29.7      180.    65.9 0.00204    785.\n10      34.9      162.    55.2 0.00209  10279.\n# … with 90 more rows\n\nVetores Especiais – factor\nfactor são fatores, que para “estatísticos” é variáveis qualitativas (veja o caso da ANOVA).\nfactor é especial pq ele no fundo é um vetor de integer sendo que cada integer é uma categoria diferentes.\n\n\nvetor_factor <- factor(c(\"A\", \"B\", \"C\"))\nstr(vetor_factor)\n\n\n Factor w/ 3 levels \"A\",\"B\",\"C\": 1 2 3\n\ntypeof(vetor_factor)\n\n\n[1] \"integer\"\n\nclass(vetor_factor)\n\n\n[1] \"factor\"\n\nunclass(vetor_factor)\n\n\n[1] 1 2 3\nattr(,\"levels\")\n[1] \"A\" \"B\" \"C\"\n\nValores Especiais\natômicos integer, logical e character: apenas um — NA\natômicos double: quatro — NA, NaN, Inf e -Inf\nvetores:\nNA - logical\nNA_integer_ - integer\nNA_real_ - double\nNA_character_ - character\n\npacote::funcao()\nÀs vezes diferentes funções possuem o mesmo nome. Como que resolvemos esse conflito de namespace.\nSimples! Nós chamamos a função com pacote::funcao()\nExemplo tibble::as_tibble()\nAmbiente\n\n\nsessionInfo()\n\n\nR version 4.0.5 (2021-03-31)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS Big Sur 10.16\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] tibble_3.1.0\n\nloaded via a namespace (and not attached):\n [1] rstudioapi_0.13   knitr_1.31        magrittr_2.0.1   \n [4] downlit_0.2.1     R6_2.5.0          ragg_1.1.2       \n [7] rlang_0.4.10      fansi_0.4.2       stringr_1.4.0    \n[10] highr_0.8         tools_4.0.5       parallel_4.0.5   \n[13] xfun_0.22         png_0.1-7         utf8_1.2.1       \n[16] cli_2.3.1         jquerylib_0.1.3   htmltools_0.5.1.1\n[19] systemfonts_1.0.1 ellipsis_0.3.1    assertthat_0.2.1 \n[22] yaml_2.2.1        digest_0.6.27     lifecycle_1.0.0  \n[25] crayon_1.4.1      textshaping_0.3.3 sass_0.3.1       \n[28] vctrs_0.3.7       distill_1.2       glue_1.4.2       \n[31] evaluate_0.14     rmarkdown_2.7     stringi_1.5.3    \n[34] pillar_1.5.1      compiler_4.0.5    bslib_0.2.4      \n[37] jsonlite_1.7.2    pkgconfig_2.0.3  \n\n\n\n\n",
      "last_modified": "2021-04-07T16:22:20+00:00"
    },
    {
      "path": "2-Manipulacao_Dados.html",
      "title": "Manipulação de Dados",
      "description": "dplyr, readr, tidyr, stringr",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 7, 2021",
      "contents": "\n\nContents\nO que é Tidy Data?\nO pipe %>%\nComo ler dados com o {readr}\ncol_types – O argumento que eu mais uso em read_*()\n\nManipulação de dados com o {dplyr}\nSelecionar Variáveis – dplyr::select()\nManipular Variáveis – dplyr::mutate()\nAgrupar e Sumarizar Variáveis – dplyr::group_by() e dplyr::summarise()\nJoins com dplyr::join*\n\nMais transformações para formato Tidy Data com {tidyr}\nExtras\nConverter verbos {dplyr} em SQL com o {dbplyr}\nBig Data com {arrow}\n\nAmbiente\n\n\n\n\n\nFigure 1: Tidy Data\n\n\n\nO que é Tidy Data?\ncada variável uma coluna\ncada observação uma linha\ncada célula uma mensuração única\nO pipe %>%\nx %>% f(y) vira f(x, y)\nx %>% f(y) %>% f(z) vira f(f(x, y), z)\n\n\nlibrary(magrittr)\n\n# atalho é CTRL + SHIFT + M\n\nc(0:10, NA) %>%\n  mean(na.rm = TRUE) %>% \n  print() %>% \n  message() %>% \n  message()\n\n\n[1] 5\n\nComo ler dados com o {readr}\nVamos começar com o primeiro passo da análise de dados: a importação dos dados.\nPara isso o {tidyverse} possui um pacote chamado {readr}.\nread_csv(): CSV padrão americano\nread_csv2(): CSV padrão europeu/brasileiro\nread_tsv(): TSV\nread_delim(): Coringa\nNa pasta datasets/ temos diversos datasets interessantes:\nadult.csv\ncountries_of_the_world.csv\ncovid_19_data.csv: versão 147 de 27/02/2021.\nSe vocês quiserem ler arquivos .xlsx ou .xls usem o pacote {readxl}\ncol_types – O argumento que eu mais uso em read_*()\n\n\nlibrary(readr)\nadult <- read_csv(\"datasets/adult.csv\",\n                  col_types = \"_iffifffif\")\n\n\n\n\n\ncountries <- read_csv(\"datasets/countries_of_the_world.csv\", \n    col_types = cols(Population = col_integer(), \n        `Net migration` = col_double()), \n    locale = locale(decimal_mark = \",\"))\n\n\n\n\n\ncovid <- read_csv(\"datasets/covid_19_data.csv\", \n    col_types = cols(SNo = col_skip(), ObservationDate = col_date(format = \"%m/%d/%Y\")))\n\n\n\nManipulação de dados com o {dplyr}\n\n\n\nFigure 2: dplyr\n\n\n\nSelecionar Variáveis – dplyr::select()\n\n\nlibrary(dplyr)\nadult_clean <- adult %>% \n  select(age, workclass, education,\n         education_num = `educational-num`,\n         marital_status = `marital-status`,\n         race, gender,\n         hours_per_week = `hours-per-week`,\n         income)\n\n\n\n\nOBS: Tem a função rename_with do {dplyr} versão 1.0.\n\n\n\nadult %>% \n  rename_with(~gsub(\"-\", \"_\", .x))\n\n\n# A tibble: 48,842 x 9\n     age workclass    education  educational_num marital_status  race \n   <int> <fct>        <fct>                <int> <fct>           <fct>\n 1    25 Private      11th                     7 Never-married   Black\n 2    38 Private      HS-grad                  9 Married-civ-sp… White\n 3    28 Local-gov    Assoc-acdm              12 Married-civ-sp… White\n 4    44 Private      Some-coll…              10 Married-civ-sp… Black\n 5    18 ?            Some-coll…              10 Never-married   White\n 6    34 Private      10th                     6 Never-married   White\n 7    29 ?            HS-grad                  9 Never-married   Black\n 8    63 Self-emp-no… Prof-scho…              15 Married-civ-sp… White\n 9    24 Private      Some-coll…              10 Never-married   White\n10    55 Private      7th-8th                  4 Married-civ-sp… White\n# … with 48,832 more rows, and 3 more variables: gender <fct>,\n#   hours_per_week <int>, income <fct>\n\n\n\nadult %>% \n  rename_with(~gsub(\"-\", \"_\", .x)) %>% \n  select(where(is.factor)) %>% \n  select(-workclass) %>% \n  rename_all(~paste0(\"antigo_\", .x))\n\n\n# A tibble: 48,842 x 5\n   antigo_education antigo_marital_status antigo_race antigo_gender\n   <fct>            <fct>                 <fct>       <fct>        \n 1 11th             Never-married         Black       Male         \n 2 HS-grad          Married-civ-spouse    White       Male         \n 3 Assoc-acdm       Married-civ-spouse    White       Male         \n 4 Some-college     Married-civ-spouse    Black       Male         \n 5 Some-college     Never-married         White       Female       \n 6 10th             Never-married         White       Male         \n 7 HS-grad          Never-married         Black       Male         \n 8 Prof-school      Married-civ-spouse    White       Male         \n 9 Some-college     Never-married         White       Female       \n10 7th-8th          Married-civ-spouse    White       Male         \n# … with 48,832 more rows, and 1 more variable: antigo_income <fct>\n\n\nProfessor eu gosto de camelCase e agora?\n\nNão tema, tem o pacote {janitor}\n\n\nlibrary(janitor)\nadult %>% clean_names(case = \"lower_camel\")\n\n\n# A tibble: 48,842 x 9\n     age workclass education educationalNum maritalStatus race  gender\n   <int> <fct>     <fct>              <int> <fct>         <fct> <fct> \n 1    25 Private   11th                   7 Never-married Black Male  \n 2    38 Private   HS-grad                9 Married-civ-… White Male  \n 3    28 Local-gov Assoc-ac…             12 Married-civ-… White Male  \n 4    44 Private   Some-col…             10 Married-civ-… Black Male  \n 5    18 ?         Some-col…             10 Never-married White Female\n 6    34 Private   10th                   6 Never-married White Male  \n 7    29 ?         HS-grad                9 Never-married Black Male  \n 8    63 Self-emp… Prof-sch…             15 Married-civ-… White Male  \n 9    24 Private   Some-col…             10 Never-married White Female\n10    55 Private   7th-8th                4 Married-civ-… White Male  \n# … with 48,832 more rows, and 2 more variables: hoursPerWeek <int>,\n#   income <fct>\n\nOrdenar variáveis com dplyr::arrange()\n\n\nadult_clean %>% \n  arrange(-age, education_num) %>% \n  select(age, education_num)\n\n\n# A tibble: 48,842 x 2\n     age education_num\n   <int>         <int>\n 1    90             2\n 2    90             4\n 3    90             4\n 4    90             4\n 5    90             5\n 6    90             6\n 7    90             6\n 8    90             7\n 9    90             7\n10    90             9\n# … with 48,832 more rows\n\nFrequencias com dplyr::count()\n\nOBS: vamos ver muito essa função quando falarmos de group_by()\n\n\n\nadult_clean %>% \n  count(age, income, sort = TRUE)\n\n\n# A tibble: 142 x 3\n     age income     n\n   <int> <fct>  <int>\n 1    23 <=50K   1307\n 2    24 <=50K   1162\n 3    22 <=50K   1161\n 4    25 <=50K   1119\n 5    27 <=50K   1117\n 6    20 <=50K   1112\n 7    28 <=50K   1101\n 8    21 <=50K   1090\n 9    26 <=50K   1068\n10    19 <=50K   1050\n# … with 132 more rows\n\nManipular Variáveis – dplyr::mutate()\n\nOdeio potência de 10\n\nuse options(scipen = 999, digits = 2)\n\n\noptions(scipen = 999, digits = 2)\ncountries <- countries %>% clean_names()\n\ncountries %>% \n  mutate(\n    log_pop = log(population),\n    area_sq_km = area_sq_mi * 2.5899985,\n    pop_density_per_sq_km = population / area_sq_km)\n\n\n# A tibble: 227 x 23\n   country      region        population area_sq_mi pop_density_per_s…\n   <chr>        <chr>              <int>      <dbl>              <dbl>\n 1 Afghanistan  ASIA (EX. NE…   31056997     647500               48  \n 2 Albania      EASTERN EURO…    3581655      28748              125. \n 3 Algeria      NORTHERN AFR…   32930091    2381740               13.8\n 4 American Sa… OCEANIA            57794        199              290. \n 5 Andorra      WESTERN EURO…      71201        468              152. \n 6 Angola       SUB-SAHARAN …   12127071    1246700                9.7\n 7 Anguilla     LATIN AMER. …      13477        102              132. \n 8 Antigua & B… LATIN AMER. …      69108        443              156  \n 9 Argentina    LATIN AMER. …   39921833    2766890               14.4\n10 Armenia      C.W. OF IND.…    2976372      29800               99.9\n# … with 217 more rows, and 18 more variables:\n#   coastline_coast_area_ratio <dbl>, net_migration <dbl>,\n#   infant_mortality_per_1000_births <dbl>, gdp_per_capita <dbl>,\n#   literacy_percent <dbl>, phones_per_1000 <dbl>,\n#   arable_percent <dbl>, crops_percent <dbl>, other_percent <dbl>,\n#   climate <dbl>, birthrate <dbl>, deathrate <dbl>,\n#   agriculture <dbl>, industry <dbl>, service <dbl>, log_pop <dbl>,\n#   area_sq_km <dbl>, pop_density_per_sq_km <dbl>\n\nO mutate ele altera variáveis in-place ou adiciona novas variáveis preservando as existentes. Mas temos também o transmute adiciona novas variáveis e dropa todas as demais.\n\n\ncountries %>% \n  transmute(\n    log_pop = log(population),\n    area_sq_km = area_sq_mi * 2.5899985,\n    pop_density_per_sq_km = population / area_sq_km)\n\n\n# A tibble: 227 x 3\n   log_pop area_sq_km pop_density_per_sq_km\n     <dbl>      <dbl>                 <dbl>\n 1   17.3    1677024.                 18.5 \n 2   15.1      74457.                 48.1 \n 3   17.3    6168703.                  5.34\n 4   11.0        515.                112.  \n 5   11.2       1212.                 58.7 \n 6   16.3    3228951.                  3.76\n 7    9.51       264.                 51.0 \n 8   11.1       1147.                 60.2 \n 9   17.5    7166241.                  5.57\n10   14.9      77182.                 38.6 \n# … with 217 more rows\n\nQuase todos os verbos (como vocês viram lá em cima) do {dplyr} tem os sufixos _if, _all e _at. Por exemplo:\n\n\ncovid %>% \n  mutate_if(is.character, as.factor)\n\n\n# A tibble: 236,017 x 7\n   ObservationDate `Province/State` `Country/Region` `Last Update`  \n   <date>          <fct>            <fct>            <fct>          \n 1 2020-01-22      Anhui            Mainland China   1/22/2020 17:00\n 2 2020-01-22      Beijing          Mainland China   1/22/2020 17:00\n 3 2020-01-22      Chongqing        Mainland China   1/22/2020 17:00\n 4 2020-01-22      Fujian           Mainland China   1/22/2020 17:00\n 5 2020-01-22      Gansu            Mainland China   1/22/2020 17:00\n 6 2020-01-22      Guangdong        Mainland China   1/22/2020 17:00\n 7 2020-01-22      Guangxi          Mainland China   1/22/2020 17:00\n 8 2020-01-22      Guizhou          Mainland China   1/22/2020 17:00\n 9 2020-01-22      Hainan           Mainland China   1/22/2020 17:00\n10 2020-01-22      Hebei            Mainland China   1/22/2020 17:00\n# … with 236,007 more rows, and 3 more variables: Confirmed <dbl>,\n#   Deaths <dbl>, Recovered <dbl>\n\ndplyr::if_else e dplyr::case_when\nUsamos o if_else quando queremos fazer um teste booleano e gerar um valor caso o teste seja verdadeiro e outro valor caso o teste seja falso. Basicamente um if ... else ...:\n\n\nadult_clean %>% \n  mutate(\n    race_black = if_else(race == \"Black\", 1L, 0L)\n  ) %>% \n  select(starts_with(\"race\"))\n\n\n# A tibble: 48,842 x 2\n   race  race_black\n   <fct>      <int>\n 1 Black          1\n 2 White          0\n 3 White          0\n 4 Black          1\n 5 White          0\n 6 White          0\n 7 Black          1\n 8 White          0\n 9 White          0\n10 White          0\n# … with 48,832 more rows\n\nTemos algo um pouco mais flexível, poderoso; porém verboso. Esse é o dplyr::case_when:\n\n\nadult_cat <- adult_clean %>% \n  mutate(\n    marital_status_cat = case_when(\n      marital_status == \"Never-married\" ~ 1L,\n      marital_status == \"Married-civ-spouse\" ~ 2L,\n      marital_status == \"Married-spouse-absent\" ~ 3L,\n      marital_status == \"Married-AF-spouse \" ~ 4L,\n      marital_status == \"Separated\" ~ 5L,\n      marital_status == \"Divorced\" ~ 6L,\n      marital_status == \"Widowed\" ~ 7L,\n      TRUE ~ NA_integer_\n    ),\n    marital_age_group = case_when(\n      marital_status_cat == 1 & age >=30 ~ \"solteirx_convictx\",\n      marital_status_cat == 1 & age <=30 ~ \"solteirx_jovem\",\n      marital_status_cat > 1 & marital_status_cat <= 4 & age >=30 ~ \"adultos_casados\",\n      marital_status_cat > 1 & marital_status_cat <= 4 & age <=30 ~ \"jovens_casados\",\n      TRUE ~ \"divorciados, separados etc\"\n    )\n  ) \n  adult_cat %>% \n    select(starts_with(\"marital\")) %>%\n    count(marital_age_group, sort = TRUE)\n\n\n# A tibble: 5 x 2\n  marital_age_group              n\n  <chr>                      <int>\n1 adultos_casados            20195\n2 solteirx_jovem             10798\n3 divorciados, separados etc  9718\n4 solteirx_convictx           5319\n5 jovens_casados              2812\n\nAgrupar e Sumarizar Variáveis – dplyr::group_by() e dplyr::summarise()\nAgrupamos dados com o dplyr::group_by() e depois usamos o dplyr::summarise() (também existe na versão inglês americano como dplyr::summarize()`) para computar valores dos grupos. Este tipo de análise é chamada comumente de split-apply-combine.\n\n\nadult_cat %>% \n  group_by(marital_age_group) %>% \n  summarise(\n    n = n(),\n    n_prop = n / nrow(.)) %>% \n  arrange(-n)\n\n\n# A tibble: 5 x 3\n  marital_age_group              n n_prop\n  <chr>                      <int>  <dbl>\n1 adultos_casados            20195 0.413 \n2 solteirx_jovem             10798 0.221 \n3 divorciados, separados etc  9718 0.199 \n4 solteirx_convictx           5319 0.109 \n5 jovens_casados              2812 0.0576\n\n\n\ncovid %>% \n  janitor::clean_names() %>% \n  group_by(country_region) %>% \n  summarise(\n    n = n(),\n    media_confirmados = mean(confirmed),\n    mediana_confirmados = median(confirmed),\n    media_mortos = mean(deaths),\n    mediana_mortos = median(deaths)\n  ) %>% \n  arrange(-mediana_mortos)\n\n\n# A tibble: 226 x 6\n   country_region     n media_confirmad… mediana_confirm… media_mortos\n   <chr>          <int>            <dbl>            <dbl>        <dbl>\n 1 Iran             375          533357.          361150        25526.\n 2 South Africa     360          564541.          627650        14975.\n 3 Argentina        362          713468.          413080.       18151.\n 4 Indonesia        363          334202.          172053        10592.\n 5 Iraq             371          272190.          215784         6416.\n 6 Ecuador          364          116916.          111680         8028.\n 7 Turkey           354          717519.          275749         9998.\n 8 Bolivia          354           98196.          119180.        5184.\n 9 Egypt            380           80259.           97192.        4399.\n10 Bangladesh       357          279329.          317528         4023.\n# … with 216 more rows, and 1 more variable: mediana_mortos <dbl>\n\nEu posso agrupar por vários grupos por exemplo:\n\n\nlibrary(tidyr)\ncovid %>% \n  janitor::clean_names() %>% \n  group_by(country_region, province_state) %>% \n  drop_na() %>% \n  count(wt = deaths, sort = TRUE)\n\n\n# A tibble: 760 x 3\n# Groups:   country_region, province_state [760]\n   country_region province_state        n\n   <chr>          <chr>             <dbl>\n 1 UK             England        13897698\n 2 US             New York       10888511\n 3 Brazil         Sao Paulo       9651617\n 4 India          Maharashtra     9117030\n 5 Italy          Lombardia       5743485\n 6 US             California      5358608\n 7 Brazil         Rio de Janeiro  5335936\n 8 US             Texas           5072817\n 9 US             New Jersey      5054435\n10 US             Florida         4153905\n# … with 750 more rows\n\nLembra que todos os verbos do {dplyr} tem o sufixo _all, _if e _at?\n\n\ncovid %>% \n  summarise_if(is.numeric, median)\n\n\n# A tibble: 1 x 3\n  Confirmed Deaths Recovered\n      <dbl>  <dbl>     <dbl>\n1      6695    127      1224\n\nNão sei o futuro das coisas _if, _at e _all, pois o lifecycle está em superseded. Então se vocês quiserem um código robusto ao tempo usem o across:\n\n\ncovid %>% \n  summarise(across(where(is.numeric), ~median(.x, na.rm = TRUE)))\n\n\n# A tibble: 1 x 3\n  Confirmed Deaths Recovered\n      <dbl>  <dbl>     <dbl>\n1      6695    127      1224\n\n\nQual a diferença de grouped_df e tibble?\n\nSe você estiver no mundo do {tidyverse} nenhuma, mas se você for dar um pipe %>% de um grouped_df em algo que não é do {tidyverse} e que somente aceita tibbles e data.frames você vai receber um erro. Nesses casos antes de “pipar” %>% você faz um ungroup():\n\n\nadult_clean %>% \n  group_by(gender) %>% \n  class() %>% \n  print\n\n\n[1] \"grouped_df\" \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nadult_clean %>% \n  group_by(gender) %>% \n  ungroup() %>% # <----- \"desgrupando\"\n  class() %>% \n  print\n\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\ncovid <- covid %>% janitor::clean_names()\ncountries <- countries %>% janitor::clean_names()\n\n\n\nJoins com dplyr::join*\nVamos para a cereja do bolo que é os famosos joins. {dplyr} tem os seguintes joins:\ninner_join(): inclui todas as observações de x e y.\nleft_join(): inclui todas as observações de x.\nright_join(): inclui todas as observações de y.\nfull_join(): inclui todas as observações de x ou y.\n\nOBS: participação especial do {stringr}\n\n\n\nlibrary(stringr)\n# antes de fazer o join vamos ver se vai dar certo\n227 - sum(countries$country %in% covid$country_region)\n\n\n[1] 42\n\n\n\ncovid %>%\n  count(country_region, wt = confirmed, sort = TRUE) %>% \n  filter(str_detect(country_region, \"China\"))\n\n\n# A tibble: 1 x 2\n  country_region        n\n  <chr>             <dbl>\n1 Mainland China 32591323\n\n\n\ncountries %>%\n  filter(str_detect(country, \"China\"))\n\n\n# A tibble: 1 x 20\n  country region             population area_sq_mi pop_density_per_sq…\n  <chr>   <chr>                   <int>      <dbl>               <dbl>\n1 China   ASIA (EX. NEAR EA… 1313973713    9596960                137.\n# … with 15 more variables: coastline_coast_area_ratio <dbl>,\n#   net_migration <dbl>, infant_mortality_per_1000_births <dbl>,\n#   gdp_per_capita <dbl>, literacy_percent <dbl>,\n#   phones_per_1000 <dbl>, arable_percent <dbl>, crops_percent <dbl>,\n#   other_percent <dbl>, climate <dbl>, birthrate <dbl>,\n#   deathrate <dbl>, agriculture <dbl>, industry <dbl>, service <dbl>\n\n\n\nlibrary(ggplot2)\ncovid %>% \n  mutate(\n    country_region = str_replace(country_region, \"Mainland China\", \"China\")\n  ) %>% \n  filter(observation_date == max(observation_date)) %>% \n  right_join(countries,\n             by = c(\"country_region\" = \"country\")) %>% \n  mutate(deaths_per_capita = deaths / population) %>% \n  ggplot(aes(x = gdp_per_capita, y = deaths_per_capita)) +\n  geom_point() +\n  geom_smooth(method = lm)\n\n\n\n\nMais transformações para formato Tidy Data com {tidyr}\nO tidyr tem o famoso drop_na(). Então se vocês forem usar o drop_na() junto com o dplyr não esqueçam do library(tidyr).\n\nOBS: vocês podem importar TODO o {tidyverse} de uma vez só com o library(tidyverse)\n\nEm especial temos as funções pivot_longer() e pivot_wider():\nDataset tidyr::relig_income\nDataset tidyr::billboard\nDataset tidyr::fish_encounters\n\n\nlibrary(tidyr)\nrelig_income %>% \n  pivot_longer(!religion,\n               names_to = \"income\",\n               values_to = \"count\") %>% \n  mutate(across(where(is.character), as.factor)) %>% \n  filter(!str_detect(income, \"Don't know\")) %>% \n  count(religion, income, wt = count, sort = TRUE)\n\n\n# A tibble: 162 x 3\n   religion         income       n\n   <fct>            <fct>    <dbl>\n 1 Evangelical Prot $50-75k   1486\n 2 Catholic         $50-75k   1116\n 3 Mainline Prot    $50-75k   1107\n 4 Evangelical Prot $20-30k   1064\n 5 Evangelical Prot $30-40k    982\n 6 Catholic         $75-100k   949\n 7 Evangelical Prot $75-100k   949\n 8 Mainline Prot    $75-100k   939\n 9 Evangelical Prot $40-50k    881\n10 Evangelical Prot $10-20k    869\n# … with 152 more rows\n\n\n\nbillboard %>% \n  pivot_longer(\n    cols = starts_with(\"wk\"),\n    names_to = \"week\",\n    values_to = \"rank\",\n    values_drop_na = TRUE\n  ) %>% \n  group_by(artist) %>% \n  summarise(\n    n = n(),\n    median_rank = median(rank)) %>% \n  arrange(-n, median_rank)\n\n\n# A tibble: 228 x 3\n   artist                  n median_rank\n   <chr>               <int>       <dbl>\n 1 Creed                 104        28.5\n 2 Lonestar               95        38  \n 3 Destiny's Child        92        13  \n 4 N'Sync                 74        12  \n 5 Sisqo                  74        25.5\n 6 3 Doors Down           73        42  \n 7 Jay-Z                  73        45  \n 8 Aguilera, Christina    67        17  \n 9 Hill, Faith            67        28  \n10 Houston, Whitney       67        54  \n# … with 218 more rows\n\n\n\nfish_encounters %>%\n  pivot_wider(\n    names_from = station,\n    values_from = seen,\n    values_fill = 0\n  ) %>% \n  pivot_longer(!fish, names_to = \"station\", values_to = \"seen\")\n\n\n# A tibble: 209 x 3\n   fish  station  seen\n   <fct> <chr>   <int>\n 1 4842  Release     1\n 2 4842  I80_1       1\n 3 4842  Lisbon      1\n 4 4842  Rstr        1\n 5 4842  Base_TD     1\n 6 4842  BCE         1\n 7 4842  BCW         1\n 8 4842  BCE2        1\n 9 4842  BCW2        1\n10 4842  MAE         1\n# … with 199 more rows\n\nAlém do unnest_wider() e unnest_longer():\nDataset repurrrsive::got_chars\n\n\nlibrary(repurrrsive)\nchars <- tibble(char = got_chars)\nchars %>%\n  unnest_wider(char) %>% \n  select(name, books, tvSeries) %>% \n  pivot_longer(!name, names_to = \"media\") %>% \n  unnest_longer(value) %>% \n  filter(media == \"tvSeries\") %>% \n  extract(value, \"season\", \"(\\\\d{1})\", convert = TRUE)\n\n\n# A tibble: 102 x 3\n   name             media    season\n   <chr>            <chr>     <int>\n 1 Theon Greyjoy    tvSeries      1\n 2 Theon Greyjoy    tvSeries      2\n 3 Theon Greyjoy    tvSeries      3\n 4 Theon Greyjoy    tvSeries      4\n 5 Theon Greyjoy    tvSeries      5\n 6 Theon Greyjoy    tvSeries      6\n 7 Tyrion Lannister tvSeries      1\n 8 Tyrion Lannister tvSeries      2\n 9 Tyrion Lannister tvSeries      3\n10 Tyrion Lannister tvSeries      4\n# … with 92 more rows\n\nUma outra maneira\n\n\nchars %>%\n  unnest_wider(char) %>% \n  select(name, books, tvSeries) %>% \n  pivot_longer(!name, names_to = \"media\") %>% \n  unnest_longer(value) %>% \n  filter(media == \"tvSeries\") %>% \n  separate(value, into = c(NA, \"season\"), sep = \" \", fill = \"right\")\n\n\n# A tibble: 102 x 3\n   name             media    season\n   <chr>            <chr>    <chr> \n 1 Theon Greyjoy    tvSeries 1     \n 2 Theon Greyjoy    tvSeries 2     \n 3 Theon Greyjoy    tvSeries 3     \n 4 Theon Greyjoy    tvSeries 4     \n 5 Theon Greyjoy    tvSeries 5     \n 6 Theon Greyjoy    tvSeries 6     \n 7 Tyrion Lannister tvSeries 1     \n 8 Tyrion Lannister tvSeries 2     \n 9 Tyrion Lannister tvSeries 3     \n10 Tyrion Lannister tvSeries 4     \n# … with 92 more rows\n\nExtras\nConverter verbos {dplyr} em SQL com o {dbplyr}\n\n\nlibrary(dplyr, warn.conflicts = FALSE)\n\ncon <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")\ncopy_to(con, mtcars)\n\nmtcars2 <- tbl(con, \"mtcars\")\n\n\n\nPosso muito bem converter verbos {dplyr} para SQL (para todos os amantes de SQL)\n\n\nsummary <- mtcars2 %>% \n  group_by(cyl) %>% \n  summarise(mpg = mean(mpg, na.rm = TRUE)) %>% \n  arrange(-mpg)\n\nsummary %>% show_query()\n\n\n<SQL>\nSELECT `cyl`, AVG(`mpg`) AS `mpg`\nFROM `mtcars`\nGROUP BY `cyl`\nORDER BY -`mpg`\n\nsummary %>% collect()\n\n\n# A tibble: 3 x 2\n    cyl   mpg\n  <dbl> <dbl>\n1     4  26.7\n2     6  19.7\n3     8  15.1\n\nBig Data com {arrow}\nAmbiente\n\n\nsessionInfo()\n\n\nR version 4.0.3 (2020-10-10)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/atlas/libblas.so.3.10.3\nLAPACK: /usr/lib/x86_64-linux-gnu/atlas/liblapack.so.3.10.3\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C          \n [3] LC_TIME=C.UTF-8        LC_COLLATE=C.UTF-8    \n [5] LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C             \n [9] LC_ADDRESS=C           LC_TELEPHONE=C        \n[11] LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] repurrrsive_1.0.0 ggplot2_3.3.3     stringr_1.4.0    \n[4] tidyr_1.1.3       janitor_2.1.0     dplyr_1.0.5      \n[7] readr_1.4.0       magrittr_2.0.1   \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.1.0  xfun_0.22         bslib_0.2.4      \n [4] purrr_0.3.4       splines_4.0.3     lattice_0.20-41  \n [7] snakecase_0.11.0  colorspace_2.0-0  vctrs_0.3.7      \n[10] generics_0.1.0    htmltools_0.5.1.1 yaml_2.2.1       \n[13] mgcv_1.8-33       blob_1.2.1        utf8_1.2.1       \n[16] rlang_0.4.10      jquerylib_0.1.3   pillar_1.5.1     \n[19] glue_1.4.2        withr_2.4.1       DBI_1.1.1        \n[22] dbplyr_2.1.0      bit64_4.0.5       lifecycle_1.0.0  \n[25] munsell_0.5.0     gtable_0.3.0      memoise_2.0.0    \n[28] evaluate_0.14     labeling_0.4.2    knitr_1.31       \n[31] fastmap_1.1.0     fansi_0.4.2       highr_0.8        \n[34] Rcpp_1.0.6        scales_1.1.1      cachem_1.0.4     \n[37] jsonlite_1.7.2    bit_4.0.4         farver_2.1.0     \n[40] distill_1.2       hms_1.0.0         png_0.1-7        \n[43] digest_0.6.27     stringi_1.5.3     grid_4.0.3       \n[46] cli_2.4.0         tools_4.0.3       sass_0.3.1       \n[49] RSQLite_2.2.5     tibble_3.1.0      crayon_1.4.1     \n[52] pkgconfig_2.0.3   downlit_0.2.1     ellipsis_0.3.1   \n[55] Matrix_1.2-18     lubridate_1.7.10  assertthat_0.2.1 \n[58] rmarkdown_2.7     rstudioapi_0.13   R6_2.5.0         \n[61] nlme_3.1-149      compiler_4.0.3   \n\n\n\n\n",
      "last_modified": "2021-04-10T01:08:28+00:00"
    },
    {
      "path": "3-Visualizacao_Dados.html",
      "title": "Visualização de Dados",
      "description": "ggplot2, scales, patchwork, e mais",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 12, 2021",
      "contents": "\n\n\n\n\nFigure 1: Crie sua Obra-Prima!\n\n\n\n\n\n\n",
      "last_modified": "2021-04-07T16:22:20+00:00"
    },
    {
      "path": "4-Programacao_Funcional.html",
      "title": "Programação Funcional",
      "description": "purrr e furrr",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 16, 2021",
      "contents": "\n\n\n\n\nFigure 1: Programação Funcional\n\n\n\n\n\n\n",
      "last_modified": "2021-04-07T16:22:20+00:00"
    },
    {
      "path": "5-Regressao.html",
      "title": "Regressão Linear e Regressão Logística",
      "description": "lm e glm",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 19, 2021",
      "contents": "\n\n\n\n\nFigure 1: Stats\n\n\n\n\n\n\n",
      "last_modified": "2021-04-07T16:22:20+00:00"
    },
    {
      "path": "index.html",
      "title": "Linguagem R",
      "description": "Disciplina de Linguaguem R para Ciência de Dados de Pós-Graduação da UNINOVE",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 5, 2021",
      "contents": "\n\nContents\nProfessor\nComo usar esse conteúdo?\nAulas\nComo citar esse conteúdo\nLicença\n\n\n\n\n\n\nFigure 1: Linguagem R\n\n\n\nRStudio: \nDisciplina de Análise de Dados com R para alunos de pós-graduação. O conteúdo é todo baseado no universo do {tidyverse}.\nSerá coberto conteúdos sobre leitura, manipulação e exportação de dados com R. Recomendo o livro R para Data Science (Figura 2) que pode ser encontrado gratuitamente aqui e possui uma versão impressa em português.\n\n\n\nFigure 2: R for Data Science\n\n\n\nProfessor\nProf. Dr. José Eduardo Storopoli - Currículo Lattes - ORCID - https://storopoli.io\njosees@uni9.pro.br\nComo usar esse conteúdo?\nEste conteúdo possui licença livre para uso (CC BY-SA). Caso queira utilizar o conteúdo para um curso ou estudos, por favor colabore nesse repositório quaisquer aprimorações que foram realizadas.\nPara configurar um ambiente local:\nClone o repositório do GitHub: git clone https://github.com/storopoli/Linguagem-R.git\nAcesse o diretório: cd Linguagem-R\nInstale os pacotes necessários: Rscript .binder/install.R\nAulas\nAula 1 - O que é R?: Tipos de Varíaveis, Estrutura de Dados, RStudio e Rmarkdown.\nAulas 2 e 3 — Manipulação de Dados: dplyr, readr, tidyr e stringr.\nAulas 4 e 5 — Visualização de Dados: ggplot2, scales, patchwork, e mais.\nAulas 6 — Programação Funcional: purrr e furrr.\nAula 7 — Regressão Linear e Regressão Logística: lm e glm.\nComo citar esse conteúdo\nPara citar o conteúdo use:\nStoropoli (2021). Linguagem R. Disponível em: https://storopoli.io/Linguagem-R.\nOu em formato BibTeX para LaTeX:\n@misc{storopoli2021linguagemR,\n  author = {Storopoli, Jose},\n  title = {Linguagem R},\n  url = {https://storopoli.io/Linguagem-R},\n  year = {2021}\n}\nLicença\nEste obra está licenciado com uma Licença Creative Commons Atribuição-CompartilhaIgual 4.0 Internacional.\n\n\n\n\n",
      "last_modified": "2021-04-06T09:56:32+00:00"
    }
  ],
  "collections": []
}
