---
title: "Programação Funcional"
description: "purrr e furrr"
author:
  - name: Jose Storopoli
    url: https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en
    affiliation: UNINOVE
    affiliation_url: https://www.uninove.br
    orcid_id: 0000-0002-0559-5176
date: April 16, 2021
citation_url: https://storopoli.io/Linguagem-R/4-Programacao_Funcional.html
slug: storopoli2021programacaofuncionalR
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<link rel="stylesheet" href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css"/>

```{r map-frosting, echo=FALSE, fig.align='center', fig.cap='Programação Funcional'}
knitr::include_graphics("images/map_frosting.png")
```


[`{purrr}`](https://purrr.tidyverse.org) tem a seguinte lógica:

Ao invés de:

```r
for (i in 1:n) {
  output[[i]] <- f(input[[i]])
}
```

Você faz:

```r
library(purrr)
list %>% map(f)    # ou map(list, f)
```

```{r exemplo-rnorm}
library(purrr)

```


* `map()` — sempre retorna uma `list`
* `map_lgl()`, `map_int()`, `map_dbl()` e `map_chr()` — retornam um vetor do tipo desejado (conversão implícita)
* `map_dfr()` e `map_dfc()` — retornaram um `data.frame` concatenando colunas (`c`) ou linhas (`r`)
* `walk()` — usado para efeitos colaterais (side-effects)

Além disso temos o `map2*` (2 listas de inputs) e o `pmap*` (lista de vetores de inputs, pode ser um `data.frame`) para múltiplos inputs.

## `map_*()`

Conversão implícita

```{r map_dbl}

```

## Professor, e a `~`?

O tio `~` (em inglês é tilde) ele funciona quando você precisa especificar funções e argumentos mais complexos:

```{r map-tilde}

```

```{r map-ggplot}
library(ggplot2)

```

Agora é um bom momento para introduzir o `purrr::walk`

* `walk()` — usado para efeitos colaterais (*side-effects*)

```{r purrr-walk}

```

```{r purrr-walk2}

```


Agora o `purrr::pwalk()`

```{r purrr-pwalk}

```

Até dá para "knitar" vários markdowns

```r
c("arquivo1.Rmd", "arquivo2.Rmd", ...) %>%    # ou fs::dir_ls(glob = "*.Rmd") lê todo o diretório
  walk(~knitr::render(.x,
                      output_format = "html_document",
                      output_dir = "relatorios/"))
```

## MOAH POWER! `{furrr}`

`{purrr}` é single-thread então vamos usar o [`{furrr}`](https://furrr.futureverse.org).

Para usar é muito fácil! Ao invés de:

* `map()`
* `map2()`
* `pmap()`
* `walk()`

Use:

* `future_map()`
* `future_map2()`
* `future_pmap()`
* `future_walk()`

```{r purrr-sleep}

```

Agora com o `{furrr}`:

```{r furrr}
library(furrr)
plan(multisession) # ou coloque no `.Rprofile` `options(Ncpus = parallel::detectCores())` e `options(mc.cores = parallel::detectCores())`
```


```{r furrr-sleep}

```

Se for mexer com coisas aleatórias é importante usar o argumento:
* `.options = furrr_options(seed = TRUE)`

```{r furrr-random}

```

```{r furrr-random2}

```

## Ambiente

```{r sessionInfo}
sessionInfo()
```
